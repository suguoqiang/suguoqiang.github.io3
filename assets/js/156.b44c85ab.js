(window.webpackJsonp=window.webpackJsonp||[]).push([[156],{651:function(e,t,v){"use strict";v.r(t);var a=v(6),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("首先，最重要的安装淘宝镜像： "),v("code",[e._v("$ npm install -g cnpm --registry=https://registry.npm.taobao.org")])]),e._v(" "),v("h3",{attrs:{id:"vue-生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期"}},[e._v("#")]),e._v(" Vue 生命周期")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("beforeCreate：\n在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。")])]),e._v(" "),v("li",[v("p",[e._v("created：\n在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。")])]),e._v(" "),v("li",[v("p",[e._v("beforeMount：\n在挂载开始之前被调用：相关的 render 函数首次被调用。\n该钩子在服务器端渲染期间不被调用。以下周期在服务端渲染期间都不被调用。")])]),e._v(" "),v("li",[v("p",[e._v("mounted：\nel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。")])]),e._v(" "),v("li",[v("p",[e._v("beforeUpdate：\n数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。")])]),e._v(" "),v("li",[v("p",[e._v("updated：\n由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。")])]),e._v(" "),v("li",[v("p",[e._v("activated：\nkeep-alive 组件激活时调用。")])]),e._v(" "),v("li",[v("p",[e._v("deactivated：\nkeep-alive 组件停用时调用。")])]),e._v(" "),v("li",[v("p",[e._v("beforeDestroy：\n实例销毁之前调用。在这一步，实例仍然完全可用。")])]),e._v(" "),v("li",[v("p",[e._v("destroyed：\nVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。")])])]),e._v(" "),v("h3",{attrs:{id:"vue-中的-mvvm-模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-中的-mvvm-模型"}},[e._v("#")]),e._v(" Vue 中的 MVVM 模型")]),e._v(" "),v("p",[e._v("Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。")]),e._v(" "),v("p",[e._v("ViewModel是Vue的核心，它是Vue的一个实例。Vue实例是作用在某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。")]),e._v(" "),v("p",[e._v("DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。")]),e._v(" "),v("h3",{attrs:{id:"vue-路由中-hash-模式和-history-模式区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-路由中-hash-模式和-history-模式区别"}},[e._v("#")]),e._v(" Vue 路由中 hash 模式和 history 模式区别")]),e._v(" "),v("ul",[v("li",[e._v("hash模式：")])]),e._v(" "),v("p",[e._v("hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，hash不会重加载页面。")]),e._v(" "),v("ul",[v("li",[e._v("history模式：")])]),e._v(" "),v("p",[e._v("history 利用了 html5 history interface 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求。")]),e._v(" "),v("p",[v("strong",[e._v("原理")]),e._v("：")]),e._v(" "),v("p",[e._v("hash 模式的原理是 onhashchange 事件，可以在 window 对象上监听这个事件。\nhistory ：hashchange 只能改变 # 后面的代码片段，history api （pushState、replaceState、go、back、forward） 则给了前端完全的自由，通过在window对象上监听popState()事件。")]),e._v(" "),v("h3",{attrs:{id:"vue-路由中-route-和-router-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-路由中-route-和-router-的区别"}},[e._v("#")]),e._v(" Vue 路由中 $route 和 $router 的区别")]),e._v(" "),v("ul",[v("li",[e._v("$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。")]),e._v(" "),v("li",[e._v("$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。")])]),e._v(" "),v("h3",{attrs:{id:"v-show和v-if指令的共同点和不同点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-show和v-if指令的共同点和不同点"}},[e._v("#")]),e._v(" v-show和v-if指令的共同点和不同点?")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("v-show")]),e._v("指令是通过修改元素的"),v("code",[e._v("display")]),e._v("CSS属性让其显示或者隐藏")]),e._v(" "),v("li",[v("code",[e._v("v-if")]),e._v("指令是直接销毁和重建DOM达到让元素显示和隐藏的效果")])]),e._v(" "),v("h3",{attrs:{id:"如何让css只在当前组件中起作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何让css只在当前组件中起作用"}},[e._v("#")]),e._v(" 如何让CSS只在当前组件中起作用?")]),e._v(" "),v("p",[e._v("将当前组件的"),v("code",[e._v("<style>")]),e._v("修改为"),v("code",[e._v("<style scoped>")])]),e._v(" "),v("h3",{attrs:{id:"keep-alive-keep-alive-的作用是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-keep-alive-的作用是什么"}},[e._v("#")]),e._v(" "),v("code",[e._v("<keep-alive></keep-alive>")]),e._v("的作用是什么?")]),e._v(" "),v("p",[v("code",[e._v("<keep-alive></keep-alive>")]),e._v(" 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。")]),e._v(" "),v("p",[e._v("大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=>返回列表=>打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用"),v("code",[e._v("<keep-alive></keep-alive>")]),e._v("进行缓存，\n这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染")]),e._v(" "),v("h3",{attrs:{id:"vue中引入组件的步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中引入组件的步骤"}},[e._v("#")]),e._v(" Vue中引入组件的步骤?")]),e._v(" "),v("p",[e._v("1）采用ES6的"),v("code",[e._v("import ... from ...")]),e._v("语法 或 CommonJS的"),v("code",[e._v("require()")]),e._v("方法引入组件。"),v("br"),e._v("\n2）对组件进行注册,代码如下：")]),e._v(" "),v("div",{staticClass:"language-vue extra-class"},[v("pre",{pre:!0,attrs:{class:"language-vue"}},[v("code",[e._v("Vue.component('my-component', \n{  template: '"),v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("div")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("A custom component!"),v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("div")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("'})\n")])])]),v("p",[e._v("3）使用组件"),v("code",[e._v("<my-component></my-component>")])]),e._v(" "),v("h3",{attrs:{id:"指令v-el的作用是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指令v-el的作用是什么"}},[e._v("#")]),e._v(" 指令"),v("code",[e._v("v-el")]),e._v("的作用是什么?")]),e._v(" "),v("p",[e._v("提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例,")]),e._v(" "),v("h3",{attrs:{id:"在vue中使用插件的步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在vue中使用插件的步骤"}},[e._v("#")]),e._v(" 在Vue中使用插件的步骤")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("采用ES6的"),v("code",[e._v("import ... from ...")]),e._v("语法。")])]),e._v(" "),v("li",[v("p",[e._v("使用全局方法"),v("code",[e._v("Vue.use( plugin )")]),e._v("使用插件,可以传入一个选项对象"),v("code",[e._v("Vue.use(MyPlugin, { someOption: true })")])])])]),e._v(" "),v("h3",{attrs:{id:"请列举出3个vue中常用的生命周期钩子函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请列举出3个vue中常用的生命周期钩子函数"}},[e._v("#")]),e._v(" 请列举出3个Vue中常用的生命周期钩子函数?")]),e._v(" "),v("ol",[v("li",[v("p",[v("strong",[e._v("created:")]),e._v(" 实例已经创建完成之后调用，在这一步，实例已经完成数据观测，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没有开始，"),v("code",[e._v("$el")]),e._v("属性目前还不可见。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("mounted:")]),e._v(" "),v("code",[e._v("el")]),e._v("被新创建的 "),v("code",[e._v("vm.$el")]),e._v(" 替换，并挂载到实例上去之后调用该钩子。如果 "),v("code",[e._v("root")]),e._v("实例挂载了一个文档内元素，当 mounted 被调用时 "),v("code",[e._v("vm.$el")]),e._v(" 也在文档内。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("activated:")]),e._v(":"),v("code",[e._v("keep-alive")]),e._v("组件激活时调用。")])])]),e._v(" "),v("h3",{attrs:{id:"请简述下vuex的原理和使用方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请简述下vuex的原理和使用方法"}},[e._v("#")]),e._v(" 请简述下Vuex的原理和使用方法")]),e._v(" "),v("p",[v("img",{attrs:{src:"http://cdn.gqsu.top/vue01.png",alt:""}})]),e._v(" "),v("p",[e._v("数据单向流动")]),e._v(" "),v("p",[e._v("一个应用可以看作是由上面三部分组成: "),v("strong",[e._v("View, Actions,State")]),e._v(",数据的流动也是从View => Actions => State =>View 以此达到数据的单向流动.")]),e._v(" "),v("p",[e._v("但是项目较大的, 组件嵌套过多的时候, 多组件共享同一个State会在数据传递时出现很多问题。Vuex就是为了解决这些问题而产生的.")]),e._v(" "),v("p",[e._v("Vuex可以被看作项目中所有组件的数据中心,我们将所有组件中共享的State抽离出来,任何组件都可以访问和操作我们的数据中心")]),e._v(" "),v("p",[e._v("Vuex的组成：一个实例化的Vuex，Store 由 "),v("strong",[e._v("state")]),e._v("，"),v("strong",[e._v("mutations")]),e._v(" 和 "),v("strong",[e._v("actions")]),e._v(" 三个属性组成:")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("state")]),e._v("中保存着共有数据。")]),e._v(" "),v("li",[e._v("改变state中的数据有且只有通过"),v("strong",[e._v("mutations")]),e._v("中的方法，且mutations中的方法必须是同步的。")]),e._v(" "),v("li",[e._v("如果要写异步的方法,需要些在"),v("strong",[e._v("actions")]),e._v("中，并通过commit到mutations中进行state中数据的更改。")])]),e._v(" "),v("h3",{attrs:{id:"vue一些常见问题解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue一些常见问题解决"}},[e._v("#")]),e._v(" Vue一些常见问题解决")]),e._v(" "),v("h4",{attrs:{id:"_1、vue项目的发布"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、vue项目的发布"}},[e._v("#")]),e._v(" 1、Vue项目的发布")]),e._v(" "),v("p",[e._v("config目录下的 index.js 文件，修改 build 的生产环境（dev 是开发环境）的 assetsPublicPath 属性，该属性对应项目名称")]),e._v(" "),v("h4",{attrs:{id:"_2、vue下路由history-mode导致页面无法渲染的问题-白屏"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、vue下路由history-mode导致页面无法渲染的问题-白屏"}},[e._v("#")]),e._v(" 2、Vue下路由History mode导致页面无法渲染的问题（白屏）")]),e._v(" "),v("p",[e._v("一般开发的单页应用都是带有#号hash模式，如果觉得带#号不美观，那么可以使用history模式")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("history: mode\n")])])]),v("p",[e._v("但是要 通过 npm run build 发布项目的时候，则需要 将其注释掉，这样路由才会加上项目名称，才可以访问。")]),e._v(" "),v("p",[e._v("https://juejin.im/post/5ad56d86518825556534ff4b")])])}),[],!1,null,null,null);t.default=s.exports}}]);