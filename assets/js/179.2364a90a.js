(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{674:function(v,_,t){"use strict";t.r(_);var a=t(6),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("简单点概括分布式与集群的关系：")]),v._v(" "),t("p",[v._v("分布式，一个业务分拆多个子业务，部署在不同的服务器上；集群，同一个业务，部署在多个服务器上。\n分布式的每一个节点，都可以用来做集群。而集群不一定就是分布式了。")]),v._v(" "),t("h3",{attrs:{id:"集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群"}},[v._v("#")]),v._v(" 集群")]),v._v(" "),t("p",[v._v("多台服务器组成的一组计算机，作为一个整体存在，向用户提供一组网络资源，这些单个的服务器就是集群的节点。")]),v._v(" "),t("p",[v._v("集群拥有以下两个特点：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("可扩展性：集群的性能不限制于单一的服务实体，新的服务实体可以动态的添加到集群，从而增强集群的性能。")])]),v._v(" "),t("li",[t("p",[v._v("高可用性：集群当其中一个节点发生故障时，这台节点上面所运行的应用程序将在另一台节点被自动接管，消除单点故障对于增强数据可用性、可达性和可靠性是非常重要的。")])])]),v._v(" "),t("p",[v._v("集群必须拥有以下两大能力：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("负载均衡：负载均衡把任务比较均匀的分布到集群环境下的计算和网络资源，以提高数据吞吐量。")])]),v._v(" "),t("li",[t("p",[v._v("错误恢复：如果集群中的某一台服务器由于故障或者维护需要无法使用，资源和应用程序将转移到可用的集群节点上，从而保证整个系统的高可用性。")])])]),v._v(" "),t("h3",{attrs:{id:"分布式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式"}},[v._v("#")]),v._v(" 分布式")]),v._v(" "),t("p",[v._v("分布式：一个业务分拆成多个子业务，或者本身就是不同的业务，部署在不同的服务器上。")]),v._v(" "),t("p",[v._v("分布式的每一个节点，都完成不同的业务，一个节点垮了，那这个业务可能就失败了。")]),v._v(" "),t("blockquote",[t("p",[v._v("与集群的区别：分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。")])]),v._v(" "),t("h3",{attrs:{id:"实际用户访问案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实际用户访问案例"}},[v._v("#")]),v._v(" 实际用户访问案例")]),v._v(" "),t("p",[v._v("用户(IP:207.17.117.20)访问域名gqsu.top，首先会通过DNS查询解析出这个域名的公网地址：198.237.202.124，接下来用户207.17.117.20会访问198.237.202.124这个地址，数据包首先会到达负载均衡设备，\n解析出的数据包的源地址是：207.17.117.20，目的地址是：199.237.202.124，当负载均衡设备将数据包转发给选中的服务器时，源地址还是：207.17.117.20，目的地址变为172.16.20.1，我们称这种方式为目的地址NAT(DNAT，目的地址转换)。\n一般来说，在服务器负载均衡中DNAT是一定要做的（还有另一种模式叫做服务器直接返回-DSR，是不做DNAT的，可自行百度），而源地址根据部署模式的不同，有时候也需要转换成别的地址，我们称之为：源地址NAT(SNAT)，一般来说，旁路模式需要做SNAT，而串接模式不需要，这里指讨论目的IP地址。\n也经过了IP地址的转换过程，数据包中源/目的地址与请求包正好对调，从服务器回来的包源地址为172.16.20.1，目的地址为207.17.117.20，到达负载均衡设备后，负载均衡设备将源地址改为198.237.202.124，然后转发给用户，保证了访问的一致性。")]),v._v(" "),t("h4",{attrs:{id:"类比集群和分布式的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类比集群和分布式的关系"}},[v._v("#")]),v._v(" 类比集群和分布式的关系")]),v._v(" "),t("p",[v._v("小饭店原来只有一个厨师，切菜洗菜备料炒菜全干。后来客人多了，厨房一个厨师忙不过来，又请了个厨师，两个厨师都能炒一样的菜，这两个厨师的关系是集群。\n为了让厨师专心炒菜，把菜做到极致，又请了个配菜师负责切菜，备菜，备料，厨师和配菜师的关系是分布式，一个配菜师也忙不过来了，又请了个配菜师，两个配菜师关系是集群。")]),v._v(" "),t("h4",{attrs:{id:"负载均衡三大特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡三大特点"}},[v._v("#")]),v._v(" 负载均衡三大特点")]),v._v(" "),t("p",[v._v("1、负载均衡算法。一般来说负载均衡设备都会默认支持多种负载均衡分发策略，例如：")]),v._v(" "),t("ul",[t("li",[v._v("轮询（RoundRobin）将请求顺序循环地发到每个服务器。当其中某个服务器发生故障，AX就把其从顺序循环队列中拿出，不参加下一次的轮询，直到其恢复正常。")]),v._v(" "),t("li",[v._v("比率（Ratio）：给每个服务器分配一个加权值为比例，根椐这个比例，把用户的请求分配到每个服务器。当其中某个服务器发生故障，AX就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。")]),v._v(" "),t("li",[v._v("优先权（Priority）：给所有服务器分组，给每个组定义优先权，将用户的请求分配给优先级最高的服务器组（在同一组内，采用预先设定的轮询或比率算法，分配用户的请求）；当最高优先级中所有服务器或者指定数量的服务器出现故障，AX将把请求送给次优先级的服务器组。这种方式，实际为用户提供一种热备份的方式。")]),v._v(" "),t("li",[v._v("最少连接数（LeastConnection）：AX会记录当前每台服务器或者服务端口上的连接数，新的连接将传递给连接数最少的服务器。当其中某个服务器发生故障，AX就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。")]),v._v(" "),t("li",[v._v("最快响应时间（Fast Reponse time）：新的连接传递给那些响应最快的服务器。当其中某个服务器发生故障，AX就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。")]),v._v(" "),t("li",[v._v("哈希算法( hash): 将客户端的源地址，端口进行哈希运算，根据运算的结果转发给一台服务器进行处理，当其中某个服务器发生故障，就把其从服务器队列中拿出，不参加下一次的用户请求的分配，直到其恢复正常。")]),v._v(" "),t("li",[v._v("基于数据包的内容分发：例如判断HTTP的URL，如果URL中带有.jpg的扩展名，就把数据包转发到指定的服务器。")])]),v._v(" "),t("p",[v._v("2、健康检查。\n　　健康检查用于检查服务器开放的各种服务的可用状态。负载均衡设备一般会配置各种健康检查方法，例如Ping，TCP，UDP，HTTP，FTP，DNS等。Ping属于第三层的健康检查，用于检查服务器IP的连通性，而TCP/UDP属于第四层的健康检查，用于检查服务端口的UP/DOWN，如果要检查的更准确，就要用到基于7层的健康检查，例如创建一个HTTP健康检查，Get一个页面回来，并且检查页面内容是否包含一个指定的字符串，如果包含，则服务是UP的，如果不包含或者取不回页面，就认为该服务器的Web服务是不可用（DOWN）的。\n比如，负载均衡设备检查到172.16.20.3这台服务器的80端口是DOWN的，负载均衡设备将不把后面的连接转发到这台服务器，而是根据算法将数据包转发到别的服务器。创建健康检查时可以设定检查的间隔时间和尝试次数，例如设定间隔时间为5秒，尝试次数为3，那么负载均衡设备每隔5秒发起一次健康检查，如果检查失败，则尝试3次，如果3次都检查失败，则把该服务标记为DOWN，然后服务器仍然会每隔5秒对DOWN的服务器进行检查，当某个时刻发现该服务器健康检查又成功了，则把该服务器重新标记为UP。健康检查的间隔时间和尝试次数要根据综合情况来设置，原则是既不会对业务产生影响，又不会对负载均衡设备造成较大负担。")]),v._v(" "),t("p",[v._v("3、会话保持。\n　　如何保证一个用户的两次http请求转发到同一个服务器，这就要求负载均衡设备配置会话保持。\n　　会话保持用于保持会话的连续性和一致性，由于服务器之间很难做到实时同步用户访问信息，这就要求把用户的前后访问会话保持到一台服务器上来处理。举个例子，用户访问一个电子商务网站，如果用户登录时是由第一台服务器来处理的，但用户购买商品的动作却由第二台服务器来处理，第二台服务器由于不知道用户信息，所以本次购买就不会成功。\n这种情况就需要会话保持，把用户的操作都通过第一台服务器来处理才能成功。当然并不是所有的访问都需要会话保持，例如服务器提供的是静态页面比如网站的新闻频道，各台服务器都有相同的内容，这种访问就不需要会话保持。\n　　绝大多数的负载均衡产品都支持两类基本的会话保持方式：源/目的地址会话保持和cookie会话保持，另外像hash，URL Persist等也是比较常用的方式，但不是所有设备都支持。基于不同的应用要配置不同的会话保持，否则会引起负载的不均衡甚至访问异常。我们主要分析B/S结构的会话保持。")]),v._v(" "),t("h4",{attrs:{id:"负载均衡常用方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡常用方案"}},[v._v("#")]),v._v(" 负载均衡常用方案")]),v._v(" "),t("ul",[t("li",[v._v("基于DNS负载均衡")]),v._v(" "),t("li",[v._v("基于硬件负载均衡")]),v._v(" "),t("li",[v._v("基于软件负载均衡")])]),v._v(" "),t("h4",{attrs:{id:"负载均衡常用策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡常用策略"}},[v._v("#")]),v._v(" 负载均衡常用策略")]),v._v(" "),t("ul",[t("li",[v._v("轮询策略")]),v._v(" "),t("li",[v._v("负载度策略")]),v._v(" "),t("li",[v._v("响应策略")]),v._v(" "),t("li",[v._v("哈希策略")])])])}),[],!1,null,null,null);_.default=s.exports}}]);