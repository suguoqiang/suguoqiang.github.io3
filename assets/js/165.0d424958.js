(window.webpackJsonp=window.webpackJsonp||[]).push([[165],{660:function(a,t,e){"use strict";e.r(t);var s=e(6),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"_1、在java中守护线程和本地线程区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、在java中守护线程和本地线程区别"}},[a._v("#")]),a._v(" 1、在java中守护线程和本地线程区别？")]),a._v(" "),e("p",[a._v("java中的线程分为两种：守护线程（Daemon）和用户线程（User）。")]),a._v(" "),e("p",[a._v("任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(boolean)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。")]),a._v(" "),e("p",[a._v("两者的区别：\n唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。")]),a._v(" "),e("p",[a._v("扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows下的监听Ctrl+break的守护进程、Finalizer守护进程、引用处理守护进程、GC守护进程。")]),a._v(" "),e("h3",{attrs:{id:"_2、线程与进程的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、线程与进程的区别"}},[a._v("#")]),a._v(" 2、线程与进程的区别？")]),a._v(" "),e("p",[a._v("进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。")]),a._v(" "),e("p",[a._v("一个程序至少有一个进程，一个进程至少有一个线程。")]),a._v(" "),e("h3",{attrs:{id:"_3、什么是多线程中的上下文切换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、什么是多线程中的上下文切换"}},[a._v("#")]),a._v(" 3、什么是多线程中的上下文切换？")]),a._v(" "),e("p",[a._v("多线程会共同使用一组计算机上的CPU，而线程数大于给程序分配的CPU数量时，为了让各个线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换。")]),a._v(" "),e("h3",{attrs:{id:"_4、死锁与活锁的区别-死锁与饥饿的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、死锁与活锁的区别-死锁与饥饿的区别"}},[a._v("#")]),a._v(" 4、死锁与活锁的区别，死锁与饥饿的区别？")]),a._v(" "),e("p",[a._v("死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。")]),a._v(" "),e("p",[a._v("产生死锁的必要条件：")]),a._v(" "),e("p",[a._v("互斥条件：所谓互斥就是进程在某一时间内独占资源。")]),a._v(" "),e("p",[a._v("请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。")]),a._v(" "),e("p",[a._v("不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。")]),a._v(" "),e("p",[a._v("循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。")]),a._v(" "),e("p",[a._v("活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。")]),a._v(" "),e("p",[a._v("活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。")]),a._v(" "),e("p",[a._v("饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。")]),a._v(" "),e("p",[a._v("Java中导致饥饿的原因：")]),a._v(" "),e("p",[a._v("高优先级线程吞噬所有的低优先级线程的CPU时间。")]),a._v(" "),e("p",[a._v("线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。")]),a._v(" "),e("p",[a._v("线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。")]),a._v(" "),e("h3",{attrs:{id:"_5、java中用到的线程调度算法是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、java中用到的线程调度算法是什么"}},[a._v("#")]),a._v(" 5、Java中用到的线程调度算法是什么？")]),a._v(" "),e("p",[a._v("采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。")]),a._v(" "),e("h3",{attrs:{id:"_6、什么是线程组-为什么在java中不推荐使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、什么是线程组-为什么在java中不推荐使用"}},[a._v("#")]),a._v(" 6、什么是线程组，为什么在Java中不推荐使用？")]),a._v(" "),e("p",[a._v("ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。")]),a._v(" "),e("p",[a._v("为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。")]),a._v(" "),e("h3",{attrs:{id:"_7、为什么使用executor框架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、为什么使用executor框架"}},[a._v("#")]),a._v(" 7、为什么使用Executor框架？")]),a._v(" "),e("p",[a._v("每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。")]),a._v(" "),e("p",[a._v("调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。")]),a._v(" "),e("p",[a._v("接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。")]),a._v(" "),e("h3",{attrs:{id:"_8、在java中executor和executors的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8、在java中executor和executors的区别"}},[a._v("#")]),a._v(" 8、在Java中Executor和Executors的区别？")]),a._v(" "),e("p",[a._v("Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。")]),a._v(" "),e("p",[a._v("Executor 接口对象能执行我们的线程任务。")]),a._v(" "),e("p",[a._v("ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。")]),a._v(" "),e("p",[a._v("使用ThreadPoolExecutor 可以创建自定义线程池。")]),a._v(" "),e("p",[a._v("Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。")]),a._v(" "),e("h3",{attrs:{id:"_9、-http-和-rpc-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9、-http-和-rpc-的区别"}},[a._v("#")]),a._v(" 9、 Http 和 RPC 的区别")]),a._v(" "),e("p",[a._v("只要是远程调用都可以叫RPC，和是不是通过http没什么关系。\n那么，调用过程，也就是通信过程之间需要协议，可以是HTTP协议、dubbo协议等、其他协议等。")]),a._v(" "),e("h3",{attrs:{id:"_10、锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10、锁"}},[a._v("#")]),a._v(" 10、锁")]),a._v(" "),e("p",[a._v("1）公平锁是指多个线程按照申请锁的顺序来获取锁。 如：ReentrantLock，默认是非公平锁。但是通过构造函数也可变成公平锁；非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。最大特点是吞吐量大，如：Synchronized。")]),a._v(" "),e("p",[a._v("2）可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。如：Synchronized、ReentrantLock")]),a._v(" "),e("p",[a._v("3）独享锁（互斥锁）是指该锁一次只能被一个线程所持有，如：ReentrantLock；共享锁（读写锁）是指该锁可被多个线程所持有，如：ReadWriteLock（读是共享锁，写是独享锁）。")]),a._v(" "),e("p",[a._v("4）悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。适用于写非常多的情况。\n乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。适用于读非常多的情况。")]),a._v(" "),e("p",[a._v("5）分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。")]),a._v(" "),e("p",[a._v("6）偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价；轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能；重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。")]),a._v(" "),e("p",[a._v("7）自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。")]),a._v(" "),e("h3",{attrs:{id:"_11、泛型方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11、泛型方法"}},[a._v("#")]),a._v(" 11、泛型方法")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("<T extends Object> T get(String key);\n")])])]),e("h3",{attrs:{id:"_12、treemap升序输出"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12、treemap升序输出"}},[a._v("#")]),a._v(" 12、TreeMap升序输出")]),a._v(" "),e("div",{staticClass:"language-JAVA extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//输出键值对呈现升序排列，使用TreeMap进行存储")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TreeMap")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" map "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TreeMap")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);